
# ВИДОСЫ
https://www.youtube.com/watch?v=QkJwSUpRGpM
https://www.youtube.com/watch?v=TdvnGw_KcFY&list=PLwcDaxeEINae8sn4rSFEIJRc6X6x03TMn&index=27


## CkassLoaders - how its work (прям хорошо на англ)
https://javarevisited.blogspot.com/2012/12/how-classloader-works-in-java.html#axzz757rK74iW
## AND READ THIS:
https://www.baeldung.com/java-classloaders

## CLASSPATH
https://javarevisited.blogspot.com/2011/01/how-classpath-work-in-java.html#axzz757rK74iW

## Потом читать это про класслоадеры - очень доходчиво
http://java-online.ru/java-classloader.xhtml
И
https://hr-vector.com/java/classloader-java
https://coderlessons.com/articles/java/ponimanie-i-rasshirenie-java-classloader
https://programmera.ru/uroki-po-java/kak-classloader-rabotaet-na-Java/


## Инструменты для запуска и разработки Java приложений, компиляция, выполнение на JVM
хорошая статья про загрузку классов и память java
https://java2blog.com/data-structures-java/


## Как происходит загрузка классов
https://javarush.ru/groups/posts/646-kak-proiskhodit-zagruzka-klassov-v-jvm


## Классификация и функции загрузчиков классов
http://www.quizful.net/post/Java

#### 2. Загрузчики классов, динамическая загрузка классов 
http://java-online.ru/java-interview-05.xhtml  
http://java-online.ru/java-classloader.xhtml (ПОДРОБНО)

Java класс может быть загружен в контекст программы каким-либо загрузчиком classloader. Виртуальные машины JVM включают хотя бы один загрузчик классов, так называемый базовый загрузчик, который загружает все основные классы из rt.jar. Базовый загрузчик никак не связан с программой. Следующий загрузчик - это загрузчик расширений, загружающий классы из $JAVA_HOME/lib/ext. Далее по иерархии идет системный загрузчик, который загружает определенные в classpath классы.
Процесс загрузки классов выполняется следующим образом. Сначала системный загрузчик проверяет наличие класса в своем кэше. Если класс найден, то он успешно загружается. В противном случае управление загрузкой передается загрузчику расширений, который также проверяет свой кэш загрузок и, в случае неудачи, передает задачу базовому загрузчику. Базовый загрузчик проверяет кэш и, в случае неудачи, пытается его загрузить. Если загрузка прошла успешно - то процесс закончен, если нет, то управление возвращается загрузчику расширений. Загрузчик расширений пытается загрузить класс и, в случае неудачи, передает задачу системному загрузчику. В завершение процесса, если системный загрузчик не сможет загрузить класс, то возбуждается исключение java.lang.ClassNotFoundException. Так в Java работает загрузка классов, так называемое делегирование загрузки.
Если в программе создаются пользовательские загрузчики, то они должны быть унаследованы от класса java.lang.ClassLoader.
Статическая и динамическая загрузка класса
Статическая загрузка класса происходит при использовании оператора "new". Динамическая загрузка происходит в режиме "run-time" с помощью статического метода класса Class.forName(className).


### Зачем нужен загрузчик классов?
https://itsobes.ru/JavaSobes/zachem-nuzhen-zagruzchik-klassov/

### На какие области делится память JVM?
https://itsobes.ru/JavaSobes/na-kakie-oblasti-delitsia-pamiat-jvm/


### ВОТ ТУТ БЫСТРО ПРО КУЧИ СТЕКИ
https://jsehelper.blogspot.com/2016/01/java-core-1.html

### Канал Уроки Java !!!!
Урок Java 349 - Модель памяти Java и алогоритмы работы сборщиков муссора-SNZeMmInVmA.mkv



### Курс Головача по выделению, расходованию памяти - короткие видеолекции (8 шт.)
https://www.youtube.com/watch?v=AxL5LgoQyNs

## Память в Java
слабые ссылки немного про garbage collector
http://appngo.ru/blog/2018/06/15/base-questions-java-memory/

### Вот отсюда взять инфу

**Регионы памяти в JVM (**)**
Краткий ответ
Java 8: Metaspace, Old Generation, Young Generation (Eden Space/Survivor Space), Stack, Constant Pool, Code Cache, GC Area.
Hard-references, weak references, soft-references, phantom-references (***)
Краткий ответ
Hard-references — стандартные ссылки на объекты, которые становится eligible for collection после недостижимости из root set
Weak-references — объекты могут быть удалены при наличии слабой ссылки на него в любое время
Soft-references — объекты могут удалятся GC при недостатке памяти
Phantom-references — объекты не доступны напрямую по ссылкам, перед удалением помещаются в очередь на удаление. Нужны для более безопасной финализации ссылок (вместо finalize)

**Рассказать про classloader'ы и их иерархию. Из за чего, например, может возникать NoClassDefFoundError, NoSuchMethodError? (***)**
Краткий ответ

**Иерархия classloader'ов**
Bootstrap
System
Application

NoClassDefFoundError может возникнуть, если нужной библиотеки с этим классом нет в classpath
NoSuchMethodError может возникнуть из-за несовместимости ваших библиотек, если зависимая библиотека A вызывает метод из старой версии библиотеки B, но в classpath есть более новая версия библиотеки B, c другой сигнатурой этого метода




### Расскажите про классы- загрузчики и про динамическую зарузку классов. 
Любой класс, используемый в джава программу так или иначе был загружен в контекст программы каким-то загрузчиком.
Все виртуальные машины джава включают хотябы один загрузчик классов, так называем базовый загрузчик. Он загружает все основные классы, это классы из rt.jar. Интересно то, что этот загрузчик никак не связан с программой, тоесть мы не можем получить например у java.lang.Object имя зарузчика, метод getClassLoader() вернет нам null.
Следующий загрузчик - это  загрузчик расширений, он загружает  классы из $JAVA_HOME/lib/ext.
Далее по иерархии идет системный  загрузчик, он загружает классы, путь к которым указан в переменно класпас.
Для примера предположим что у нас есть некий пользовательский класс MyClass и мы его используем. Как идет его загрузка… :
Сначала системный загрузчик пытается найти  его в своем кэше загрузок его, если найден - класс успешно загружается, иначе управление загрузкой передается загрузчику расширений, он также проверяет  свой кэш загрузок и в случае неудачи  передает задачу базовому загрузчику. Тот проверяет кэш и в случае неудачи пытается его загрузить, если загрузка прошла успешно -  загрузка закончена. Если нет - передает управление загрузчику расширений. Загрузчик  расширений пытается загрузить класс  и в случае неудачи передает это  дело системному загрузчику. Системный  загрузчик пытается загрузить класс  и в случае неудачи возбуждается исключение java.lang.ClassNotFoundException.
Вот так работает загрузка классов в  джава. Так называемое делегирование загрузки.
Если  в системе присутствуют пользовательские загрузики, то они должны быть унаследованы от класса java.lang.ClassLoader .
Что же такое статическая и что  такое динамическая загрузка класса?
Статическая загрузка класса происходит при использовании  оператора "new".
Динамическая  загрузка происходит "на лету" в  ходе выполнения программы с помощью  статического метода класса Class.forName(имя класса). Для чего нужна динамическая загрузка? Например мы не знаем какой класс нам понадобится и принимаем решение в ходе выполнения программы передавая имя класса в статический метод forName().


### Что такое Heap и Stack память в Java?
Java Heap (куча)  - динамически распредляемая область памяти, создаваемая при старте JVM. Используется Java Runtime для выделения памяти под объекты и JRE классы. Создание нового объекта также происходит в куче. Здесь работает сборщик мусора: освобождает память путем удаления объектов, на которые нет каких-либо ссылок. Любой объект, созданный в куче, имеет глобальный доступ и на него могут ссылаться с любой части приложения.
Cтрогими тезами:
Все обьекты обитают в куче и попадают туда при создании.
обьект состоит из полей класса и методов.
в куче выделяется место под сам обьект, количество выделенной памяти зависит от полей, если у тебя полем класса, к примеру, служит интовая переменная, то не важно, инициализируешь ты ее как "0" или как "1000000" - обьект займет в куче свои биты, + столько байт сколько вмещает тип int(+32 бита), и так с каждым полем.
Стековая память в Java работает по схеме LIFO (Последний-зашел-Первый-вышел). Всякий раз, когда вызывается метод, в памяти стека создается новый блок, который содержит примитивы и ссылки на другие объекты в методе расположение в RAM и достижение процессору через указатель стека. Как только метод заканчивает работу, блок также перестает использоваться, тем самым предоставляя доступ для следующего метода. Размер стековой памяти намного меньше объема памяти в куче.
Cтрогими тезами:
Все методы обитают в стеке и попадают туда при вызове.
Переменные в методах так же имеют стековую память, по скольку они локальные.
Если в методе создается обьект, то он помещается в кучу, но его ссылка все еще будет находится в стеке и после того как метод покинет стек - обьект станет жертвой сборщика мусора, так как ссылка на него утеряна, и из главного стека программы невозможно будет добраться до такого обьекта.

### Какая разница между Stack и Heap памятью в Java?
Приведем следующие различия между Heap и Stack памятью в Java.
Куча используется всеми частями приложения в то время как стек используется только одним потоком исполнения программы.
Всякий раз, когда создается объект, он всегда хранится в куче, а в памяти стека содержится ссылка на него. Память стека содержит только локальные переменные примитивных типов и ссылки на объекты в куче.
Объекты в куче доступны с любой точки программы, в то время как стековая память не может быть доступна для других потоков.
Управление памятью в стеке осуществляется по схеме LIFO.
Стековая память существует лишь какое-то время работы программы, а память в куче живет с самого начала до конца работы программы.
Мы можем использовать -Xms и -Xmx опции JVM, чтобы определить начальный и максимальный размер памяти в куче. Для стека определить размер памяти можно с помощью опции -Xss .
Если память стека полностью занята, то Java Runtime бросает java.lang.StackOverflowError, а если память кучи заполнена, то бросается исключение java.lang.OutOfMemoryError: Java Heap Space.
Размер памяти стека намного меньше памяти в куче. Из-за простоты распределения памяти (LIFO), стековая память работает намного быстрее кучи.

### Расскажите про модель памяти  в джава?
В Джаве память устроена следующим  образом, есть два вида:
куча
стек
Куча  состоит из статического контекста  и самой кучи
Перейдем  к куче. Куча состоит из двух частей:
Новая куча
Старая куча
Новая куча в свою очередь состоит из двух частей:
Eden(назовем ее первая) куча
Survival(выжившая) куча
Краткое описание:
Eden Space (heap) - в этой области выделятся память под все создаваемые из программы объекты. Большая часть объектов живет недолго (итераторы, временные объекты, используемые внутри методов и т.п.), и удаляются при выполнении сборок мусора это области памяти, не перемещаются в другие области памяти. Когда данная область заполняется (т.е. количество выделенной памяти в этой области превышает некоторый заданный процент), GC выполняет быструю (minor collection) сборку мусора. По сравнению с полной сборкой мусора она занимает мало времени, и затрагивает только эту область памяти - очищает от устаревших объектов Eden Space и перемещает выжившие объекты в следующую область. 
Survivor Space (heap) – сюда перемещаются объекты из предыдущей, после того, как они пережили хотя бы одну сборку мусора. Время от времени долгоживущие объекты из этой области перемещаются в Tenured Space.
Tenured (Old) Generation (heap) - Здесь скапливаются долгоживущие объекты (крупные высокоуровневые объекты, синглтоны, менеджеры ресурсов и проч.). Когда заполняется эта область, выполняется полная сборка мусора (full, major collection), которая обрабатывает все созданные JVM объекты.
Permanent Generation (non-heap) - Здесь хранится метаинформация, используемая JVM (используемые классы, методы и т.п.). 



### Стек и куча в Java
https://topjava.ru/blog/stack-and-heap-in-java


### Опишите процесс создания экземпляра класса
https://itsobes.ru/JavaSobes/opishite-protsess-sozdaniia-ekzempliara-klassa/

### Из чего состоит .class
https://itsobes.ru/JavaSobes/iz-chego-sostoit-class-fail/

## Иерархия класслоадеров, загрузчики, англ, но толковое
http://www.martinlippert.org/events/WJAX2008-ClassloadingTypeVisibilityOSGi.pdf

###


####